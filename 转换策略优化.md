# Figma到React组件转换策略优化

## 当前转换流程

```
Figma API数据 → 节点树遍历 → JSX生成 → CSS生成 → React组件
```

## 优化策略

### 1. 数据预处理阶段

在转换之前，应该对Figma数据进行预处理：

#### 1.1 计算相对位置
```javascript
function calculateRelativePosition(node, parentNode) {
  if (!node.absoluteBoundingBox || !parentNode?.absoluteBoundingBox) {
    return null;
  }
  
  return {
    x: node.absoluteBoundingBox.x - parentNode.absoluteBoundingBox.x,
    y: node.absoluteBoundingBox.y - parentNode.absoluteBoundingBox.y,
    width: node.absoluteBoundingBox.width,
    height: node.absoluteBoundingBox.height
  };
}
```

#### 1.2 识别布局模式
```javascript
function detectLayoutMode(node) {
  // 优先使用layoutMode
  if (node.layoutMode) {
    return node.layoutMode;
  }
  
  // 通过子元素位置推断
  if (node.children && node.children.length > 1) {
    return detectHorizontalLayout(node) ? 'HORIZONTAL' : 'VERTICAL';
  }
  
  return 'NONE';
}
```

#### 1.3 提取样式信息
```javascript
function extractStyleInfo(node) {
  return {
    fills: node.fills?.filter(f => f.visible !== false) || [],
    strokes: node.strokes?.filter(s => s.visible !== false) || [],
    cornerRadius: node.cornerRadius || 0,
    opacity: node.opacity ?? 1,
    effects: node.effects || [],
    layout: {
      mode: node.layoutMode,
      alignItems: node.counterAxisAlignItems,
      justifyContent: node.primaryAxisAlignItems,
      gap: node.itemSpacing,
      padding: {
        top: node.paddingTop || node.layoutPaddingTop || 0,
        right: node.paddingRight || node.layoutPaddingRight || 0,
        bottom: node.paddingBottom || node.layoutPaddingBottom || 0,
        left: node.paddingLeft || node.layoutPaddingLeft || 0
      }
    },
    constraints: node.constraints,
    textStyle: node.type === 'TEXT' ? node.style : null
  };
}
```

### 2. 组件识别优化

#### 2.1 更智能的组件识别
```javascript
function shouldBeComponent(node, depth = 0) {
  // 1. Figma原生组件
  if (node.type === 'COMPONENT' || node.type === 'INSTANCE') {
    return true;
  }
  
  // 2. 命名模式识别
  const name = (node.name || '').toLowerCase();
  const componentKeywords = ['card', 'button', 'input', 'modal', 'dialog'];
  if (componentKeywords.some(kw => name.includes(kw))) {
    return true;
  }
  
  // 3. 结构特征识别
  // - 有明确的布局模式
  // - 有多个子元素
  // - 有明确的样式边界
  if (node.layoutMode && 
      node.children && 
      node.children.length >= 2 &&
      depth < 3) {
    return true;
  }
  
  return false;
}
```

### 3. 样式生成优化

#### 3.1 更准确的布局转换
```javascript
function convertLayoutToCSS(layoutInfo) {
  const rules = [];
  
  if (layoutInfo.mode === 'HORIZONTAL' || layoutInfo.mode === 'VERTICAL') {
    rules.push('display: flex;');
    rules.push(`flex-direction: ${layoutInfo.mode === 'HORIZONTAL' ? 'row' : 'column'};`);
    
    // 对齐方式
    if (layoutInfo.justifyContent) {
      const map = {
        'MIN': 'flex-start',
        'CENTER': 'center',
        'MAX': 'flex-end',
        'SPACE_BETWEEN': 'space-between'
      };
      rules.push(`justify-content: ${map[layoutInfo.justifyContent] || 'flex-start'};`);
    }
    
    if (layoutInfo.alignItems) {
      const map = {
        'MIN': 'flex-start',
        'CENTER': 'center',
        'MAX': 'flex-end',
        'STRETCH': 'stretch'
      };
      rules.push(`align-items: ${map[layoutInfo.alignItems] || 'stretch'};`);
    }
    
    // 间距
    if (layoutInfo.gap) {
      rules.push(`gap: ${layoutInfo.gap}px;`);
    }
    
    // 内边距
    const { padding } = layoutInfo;
    if (padding.top || padding.right || padding.bottom || padding.left) {
      if (padding.top === padding.right && 
          padding.right === padding.bottom && 
          padding.bottom === padding.left) {
        rules.push(`padding: ${padding.top}px;`);
      } else {
        rules.push(
          `padding: ${padding.top}px ${padding.right}px ${padding.bottom}px ${padding.left}px;`
        );
      }
    }
  }
  
  return rules;
}
```

#### 3.2 约束处理
```javascript
function convertConstraintsToCSS(constraints, bbox) {
  const rules = [];
  
  if (!constraints) return rules;
  
  // 水平约束
  if (constraints.horizontal === 'STRETCH') {
    rules.push('width: 100%;');
  } else if (constraints.horizontal === 'SCALE') {
    if (bbox?.width) {
      rules.push(`width: 100%;`);
      rules.push(`max-width: ${bbox.width}px;`);
    }
  }
  
  // 垂直约束
  if (constraints.vertical === 'STRETCH') {
    rules.push('height: 100%;');
  } else if (constraints.vertical === 'SCALE') {
    if (bbox?.height) {
      rules.push(`height: 100%;`);
      rules.push(`max-height: ${bbox.height}px;`);
    }
  }
  
  return rules;
}
```

### 4. 位置计算优化

#### 4.1 绝对定位处理
```javascript
function calculateAbsolutePosition(node, parentNode) {
  if (!node.absoluteBoundingBox || !parentNode?.absoluteBoundingBox) {
    return null;
  }
  
  const nodeBox = node.absoluteBoundingBox;
  const parentBox = parentNode.absoluteBoundingBox;
  
  return {
    position: 'absolute',
    left: `${nodeBox.x - parentBox.x}px`,
    top: `${nodeBox.y - parentBox.y}px`,
    width: `${nodeBox.width}px`,
    height: `${nodeBox.height}px`
  };
}
```

### 5. 组件结构优化

#### 5.1 减少嵌套
```javascript
function shouldSkipNode(node, parentNode) {
  // 1. GROUP类型且无样式
  if (node.type === 'GROUP' && 
      !hasStyle(node) && 
      node.children?.length === 1) {
    return true;
  }
  
  // 2. 无意义的容器
  if (node.type === 'FRAME' && 
      !node.layoutMode && 
      !hasStyle(node) &&
      node.children?.length === 1) {
    return true;
  }
  
  return false;
}
```

#### 5.2 合并相邻元素
```javascript
function mergeSimilarNodes(nodes) {
  // 合并相同类型的相邻节点
  // 例如：多个连续的文本节点可以合并
  const merged = [];
  let currentGroup = null;
  
  for (const node of nodes) {
    if (node.type === 'TEXT' && 
        currentGroup?.type === 'TEXT' &&
        shouldMergeText(currentGroup, node)) {
      // 合并文本节点
      currentGroup.characters += ' ' + node.characters;
    } else {
      if (currentGroup) merged.push(currentGroup);
      currentGroup = node;
    }
  }
  
  if (currentGroup) merged.push(currentGroup);
  return merged;
}
```

## 改进建议

### 1. 添加数据验证
在转换前验证Figma数据的完整性：
- 检查必需的字段
- 验证数据格式
- 处理缺失的数据

### 2. 缓存计算结果
对于大型设计稿，缓存已计算的样式和位置信息：
```javascript
const styleCache = new Map();
const positionCache = new Map();
```

### 3. 支持增量更新
只转换变更的节点，而不是整个设计稿。

### 4. 更好的错误处理
- 处理缺失的样式信息
- 处理无效的布局配置
- 提供有意义的错误信息

### 5. 配置化转换规则
允许用户自定义：
- 组件识别规则
- 样式转换规则
- 标签映射规则

## 实际应用示例

### 示例1：按钮组件
```javascript
// Figma数据
{
  type: 'FRAME',
  name: 'Button',
  layoutMode: 'HORIZONTAL',
  primaryAxisAlignItems: 'CENTER',
  counterAxisAlignItems: 'CENTER',
  paddingLeft: 16,
  paddingRight: 16,
  cornerRadius: 8,
  fills: [{ type: 'SOLID', color: { r: 0.2, g: 0.4, b: 0.8 } }],
  children: [
    { type: 'TEXT', characters: 'Click me' }
  ]
}

// 生成的React组件
<button className="button" style={{ 
  display: 'flex',
  flexDirection: 'row',
  justifyContent: 'center',
  alignItems: 'center',
  padding: '12px 16px',
  borderRadius: '8px',
  backgroundColor: 'rgba(51, 102, 204, 1)'
}}>
  Click me
</button>
```

### 示例2：卡片组件
```javascript
// Figma数据
{
  type: 'FRAME',
  name: 'Card',
  layoutMode: 'VERTICAL',
  itemSpacing: 16,
  cornerRadius: 12,
  fills: [{ type: 'SOLID', color: { r: 1, g: 1, b: 1 } }],
  effects: [{ type: 'DROP_SHADOW', ... }],
  children: [
    { type: 'TEXT', characters: 'Title' },
    { type: 'TEXT', characters: 'Description' }
  ]
}

// 生成的React组件
<div className="card" style={{
  display: 'flex',
  flexDirection: 'column',
  gap: '16px',
  borderRadius: '12px',
  backgroundColor: 'white',
  boxShadow: '...'
}}>
  <p>Title</p>
  <p>Description</p>
</div>
```
